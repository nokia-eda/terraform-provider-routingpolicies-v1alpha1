// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_policy

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func PolicyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^routingpolicies\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("routingpolicies.eda.nokia.com/v1alpha1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Policy$"), ""),
				},
				Default: stringdefault.StaticString("Policy"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Policy",
				MarkdownDescription: "name of the Policy",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"default_action": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bgp": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"as_path_prepend": schema.Int64Attribute{
										Optional:            true,
										Description:         "AS number to prepend to the AS Path attributes.",
										MarkdownDescription: "AS number to prepend to the AS Path attributes.",
										Validators: []validator.Int64{
											int64validator.Between(1, 4294967295),
										},
									},
									"as_path_remove": schema.BoolAttribute{
										Optional:            true,
										Description:         "Clear the AS path to make it empty.",
										MarkdownDescription: "Clear the AS path to make it empty.",
									},
									"as_path_replace": schema.ListAttribute{
										ElementType:         types.Int64Type,
										Optional:            true,
										Description:         "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
										MarkdownDescription: "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
									},
									"community_set": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"add": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "List of community sets to add to the route.",
												MarkdownDescription: "List of community sets to add to the route.",
												Validators: []validator.List{
													listvalidator.SizeAtMost(1),
												},
											},
											"remove": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "List of community sets to remove from the route.",
												MarkdownDescription: "List of community sets to remove from the route.",
												Validators: []validator.List{
													listvalidator.SizeAtMost(1),
												},
											},
											"replace": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
												MarkdownDescription: "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
												Validators: []validator.List{
													listvalidator.SizeAtMost(1),
												},
											},
										},
										CustomType: CommunitySetType{
											ObjectType: types.ObjectType{
												AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "Modify BGP communities associated with the route using hybrid Community Sets.",
										MarkdownDescription: "Modify BGP communities associated with the route using hybrid Community Sets.",
									},
									"local_preference": schema.Int64Attribute{
										Optional:            true,
										Description:         "Set a new LOCAL_PREF value for matching BGP routes.",
										MarkdownDescription: "Set a new LOCAL_PREF value for matching BGP routes.",
										Validators: []validator.Int64{
											int64validator.Between(0, 4294967295),
										},
									},
									"med": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"numerical_value": schema.Int64Attribute{
												Optional:            true,
												Description:         "Fixed numerical value to set or add/subtract.",
												MarkdownDescription: "Fixed numerical value to set or add/subtract.",
												Validators: []validator.Int64{
													int64validator.Between(0, 4294967295),
												},
											},
											"operation": schema.StringAttribute{
												Optional:            true,
												Description:         "The operation to perform on the MED value.",
												MarkdownDescription: "The operation to perform on the MED value.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Set",
														"Add",
														"Subtract",
													),
												},
											},
											"value_type": schema.StringAttribute{
												Optional:            true,
												Description:         "Use a fixed value or an IGP metric to adjust the MED.",
												MarkdownDescription: "Use a fixed value or an IGP metric to adjust the MED.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Fixed",
														"IGP",
													),
												},
											},
										},
										CustomType: MedType{
											ObjectType: types.ObjectType{
												AttrTypes: MedValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "Set a new MED value.",
										MarkdownDescription: "Set a new MED value.",
									},
									"set_origin": schema.StringAttribute{
										Optional:            true,
										Description:         "Set a new ORIGIN attribute for matching BGP routes.",
										MarkdownDescription: "Set a new ORIGIN attribute for matching BGP routes.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"egp",
												"igp",
												"incomplete",
											),
										},
									},
								},
								CustomType: BgpType{
									ObjectType: types.ObjectType{
										AttrTypes: BgpValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Actions related to the BGP protocol.",
								MarkdownDescription: "Actions related to the BGP protocol.",
							},
							"policy_result": schema.StringAttribute{
								Optional:            true,
								Description:         "Final disposition for the route.",
								MarkdownDescription: "Final disposition for the route.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"accept",
										"reject",
										"NextPolicy",
										"NextStatement",
									),
								},
							},
						},
						CustomType: DefaultActionType{
							ObjectType: types.ObjectType{
								AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "The default action to apply if no other actions are defined.",
						MarkdownDescription: "The default action to apply if no other actions are defined.",
					},
					"statement": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"action": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bgp_1": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"as_path_prepend": schema.Int64Attribute{
													Optional:            true,
													Description:         "AS number to prepend to the AS Path attributes.",
													MarkdownDescription: "AS number to prepend to the AS Path attributes.",
													Validators: []validator.Int64{
														int64validator.Between(1, 4294967295),
													},
												},
												"as_path_remove": schema.BoolAttribute{
													Optional:            true,
													Description:         "Clear the AS path to make it empty.",
													MarkdownDescription: "Clear the AS path to make it empty.",
												},
												"as_path_replace": schema.ListAttribute{
													ElementType:         types.Int64Type,
													Optional:            true,
													Description:         "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
													MarkdownDescription: "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
												},
												"community_set_1": schema.SingleNestedAttribute{
													Attributes: map[string]schema.Attribute{
														"add": schema.ListAttribute{
															ElementType:         types.StringType,
															Optional:            true,
															Description:         "List of community sets to add to the route.",
															MarkdownDescription: "List of community sets to add to the route.",
															Validators: []validator.List{
																listvalidator.SizeAtMost(1),
															},
														},
														"remove": schema.ListAttribute{
															ElementType:         types.StringType,
															Optional:            true,
															Description:         "List of community sets to remove from the route.",
															MarkdownDescription: "List of community sets to remove from the route.",
															Validators: []validator.List{
																listvalidator.SizeAtMost(1),
															},
														},
														"replace": schema.ListAttribute{
															ElementType:         types.StringType,
															Optional:            true,
															Description:         "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
															MarkdownDescription: "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
															Validators: []validator.List{
																listvalidator.SizeAtMost(1),
															},
														},
													},
													CustomType: CommunitySet1Type{
														ObjectType: types.ObjectType{
															AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
														},
													},
													Optional:            true,
													Description:         "Modify BGP communities associated with the route using hybrid Community Sets.",
													MarkdownDescription: "Modify BGP communities associated with the route using hybrid Community Sets.",
												},
												"local_preference": schema.Int64Attribute{
													Optional:            true,
													Description:         "Set a new LOCAL_PREF value for matching BGP routes.",
													MarkdownDescription: "Set a new LOCAL_PREF value for matching BGP routes.",
													Validators: []validator.Int64{
														int64validator.Between(0, 4294967295),
													},
												},
												"med_1": schema.SingleNestedAttribute{
													Attributes: map[string]schema.Attribute{
														"numerical_value": schema.Int64Attribute{
															Optional:            true,
															Description:         "Fixed numerical value to set or add/subtract.",
															MarkdownDescription: "Fixed numerical value to set or add/subtract.",
															Validators: []validator.Int64{
																int64validator.Between(0, 4294967295),
															},
														},
														"operation": schema.StringAttribute{
															Optional:            true,
															Description:         "The operation to perform on the MED value.",
															MarkdownDescription: "The operation to perform on the MED value.",
															Validators: []validator.String{
																stringvalidator.OneOf(
																	"Set",
																	"Add",
																	"Subtract",
																),
															},
														},
														"value_type": schema.StringAttribute{
															Optional:            true,
															Description:         "Use a fixed value or an IGP metric to adjust the MED.",
															MarkdownDescription: "Use a fixed value or an IGP metric to adjust the MED.",
															Validators: []validator.String{
																stringvalidator.OneOf(
																	"Fixed",
																	"IGP",
																),
															},
														},
													},
													CustomType: Med1Type{
														ObjectType: types.ObjectType{
															AttrTypes: Med1Value{}.AttributeTypes(ctx),
														},
													},
													Optional:            true,
													Description:         "Set a new MED value.",
													MarkdownDescription: "Set a new MED value.",
												},
												"set_origin": schema.StringAttribute{
													Optional:            true,
													Description:         "Set a new ORIGIN attribute for matching BGP routes.",
													MarkdownDescription: "Set a new ORIGIN attribute for matching BGP routes.",
													Validators: []validator.String{
														stringvalidator.OneOf(
															"egp",
															"igp",
															"incomplete",
														),
													},
												},
											},
											CustomType: Bgp1Type{
												ObjectType: types.ObjectType{
													AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Actions related to the BGP protocol.",
											MarkdownDescription: "Actions related to the BGP protocol.",
										},
										"policy_result": schema.StringAttribute{
											Optional:            true,
											Description:         "Final disposition for the route.",
											MarkdownDescription: "Final disposition for the route.",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"accept",
													"reject",
													"NextPolicy",
													"NextStatement",
												),
											},
										},
									},
									CustomType: ActionType{
										ObjectType: types.ObjectType{
											AttrTypes: ActionValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Actions for routes that match the policy statement.",
									MarkdownDescription: "Actions for routes that match the policy statement.",
								},
								"match": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bgp_2": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"as_path_match": schema.SingleNestedAttribute{
													Attributes: map[string]schema.Attribute{
														"as_path_expression": schema.StringAttribute{
															Optional:            true,
															Description:         "A singular regular expression string to match against AS_PATH objects. Mutually exclusive with the ASPathSet reference.",
															MarkdownDescription: "A singular regular expression string to match against AS_PATH objects. Mutually exclusive with the ASPathSet reference.",
														},
														"as_path_set": schema.StringAttribute{
															Optional:            true,
															Description:         "Reference to an ASPathSet resource. Mutually exclusive with the ASPathExpression.",
															MarkdownDescription: "Reference to an ASPathSet resource. Mutually exclusive with the ASPathExpression.",
														},
														"match_set_options": schema.StringAttribute{
															Optional:            true,
															Description:         "The matching criteria that applies to the members in the referenced set.",
															MarkdownDescription: "The matching criteria that applies to the members in the referenced set.",
															Validators: []validator.String{
																stringvalidator.OneOf(
																	"Any",
																	"All",
																	"Invert",
																),
															},
														},
													},
													CustomType: AsPathMatchType{
														ObjectType: types.ObjectType{
															AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
														},
													},
													Optional:            true,
													Description:         "AS Path match criteria.",
													MarkdownDescription: "AS Path match criteria.",
												},
												"community_set": schema.StringAttribute{
													Optional:            true,
													Description:         "Match conditions for BGP communities.",
													MarkdownDescription: "Match conditions for BGP communities.",
												},
												"evpn_route_type": schema.ListAttribute{
													ElementType:         types.Int64Type,
													Optional:            true,
													Description:         "Match conditions for EVPN route types.",
													MarkdownDescription: "Match conditions for EVPN route types.",
												},
											},
											CustomType: Bgp2Type{
												ObjectType: types.ObjectType{
													AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Configuration for BGP-specific policy match criteria.",
											MarkdownDescription: "Configuration for BGP-specific policy match criteria.",
										},
										"family": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "Address families that the route belongs to.",
											MarkdownDescription: "Address families that the route belongs to.",
										},
										"prefix_set": schema.StringAttribute{
											Optional:            true,
											Description:         "Reference to a PrefixSet resource.",
											MarkdownDescription: "Reference to a PrefixSet resource.",
										},
										"protocol": schema.StringAttribute{
											Optional:            true,
											Description:         "The route protocol type to match.",
											MarkdownDescription: "The route protocol type to match.",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"AGGREGATE",
													"ARP_ND",
													"BGP",
													"BGP_EVPN",
													"DHCP",
													"GRIBI",
													"HOST",
													"ISIS",
													"LOCAL",
													"LINUX",
													"NDK1",
													"NDK2",
													"OSPFV2",
													"OSPFV3",
													"STATIC",
												),
											},
										},
									},
									CustomType: MatchType{
										ObjectType: types.ObjectType{
											AttrTypes: MatchValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Match conditions of the policy statement.",
									MarkdownDescription: "Match conditions of the policy statement.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "Name of the policy statement.",
									MarkdownDescription: "Name of the policy statement.",
								},
							},
							CustomType: StatementType{
								ObjectType: types.ObjectType{
									AttrTypes: StatementValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "List of policy statements.",
						MarkdownDescription: "List of policy statements.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "Policy defines a set of rules and actions to manage network traffic or routing behavior, with statements that include matching conditions and actions, such as accepting or rejecting routes, or modifying route attributes like BGP parameters.",
				MarkdownDescription: "Policy defines a set of rules and actions to manage network traffic or routing behavior, with statements that include matching conditions and actions, such as accepting or rejecting routes, or modifying route attributes like BGP parameters.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "PolicyStatus defines the observed state of Policy.",
				MarkdownDescription: "PolicyStatus defines the observed state of Policy.",
			},
		},
	}
}

type PolicyModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultActionAttribute, ok := attributes["default_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_action is missing from object`)

		return nil, diags
	}

	defaultActionVal, ok := defaultActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_action expected to be basetypes.ObjectValue, was: %T`, defaultActionAttribute))
	}

	statementAttribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement is missing from object`)

		return nil, diags
	}

	statementVal, ok := statementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement expected to be basetypes.ListValue, was: %T`, statementAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		DefaultAction: defaultActionVal,
		Statement:     statementVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	defaultActionAttribute, ok := attributes["default_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_action is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	defaultActionVal, ok := defaultActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_action expected to be basetypes.ObjectValue, was: %T`, defaultActionAttribute))
	}

	statementAttribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	statementVal, ok := statementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement expected to be basetypes.ListValue, was: %T`, statementAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		DefaultAction: defaultActionVal,
		Statement:     statementVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	DefaultAction basetypes.ObjectValue `tfsdk:"default_action"`
	Statement     basetypes.ListValue   `tfsdk:"statement"`
	state         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["default_action"] = basetypes.ObjectType{
		AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.ListType{
		ElemType: StatementValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DefaultAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_action"] = val

		val, err = v.Statement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var defaultAction basetypes.ObjectValue

	if v.DefaultAction.IsNull() {
		defaultAction = types.ObjectNull(
			DefaultActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.DefaultAction.IsUnknown() {
		defaultAction = types.ObjectUnknown(
			DefaultActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DefaultAction.IsNull() && !v.DefaultAction.IsUnknown() {
		defaultAction = types.ObjectValueMust(
			DefaultActionValue{}.AttributeTypes(ctx),
			v.DefaultAction.Attributes(),
		)
	}

	statement := types.ListValueMust(
		StatementType{
			basetypes.ObjectType{
				AttrTypes: StatementValue{}.AttributeTypes(ctx),
			},
		},
		v.Statement.Elements(),
	)

	if v.Statement.IsNull() {
		statement = types.ListNull(
			StatementType{
				basetypes.ObjectType{
					AttrTypes: StatementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement.IsUnknown() {
		statement = types.ListUnknown(
			StatementType{
				basetypes.ObjectType{
					AttrTypes: StatementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"default_action": basetypes.ObjectType{
			AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
		},
		"statement": basetypes.ListType{
			ElemType: StatementValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_action": defaultAction,
			"statement":      statement,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultAction.Equal(other.DefaultAction) {
		return false
	}

	if !v.Statement.Equal(other.Statement) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_action": basetypes.ObjectType{
			AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
		},
		"statement": basetypes.ListType{
			ElemType: StatementValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DefaultActionType{}

type DefaultActionType struct {
	basetypes.ObjectType
}

func (t DefaultActionType) Equal(o attr.Type) bool {
	other, ok := o.(DefaultActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DefaultActionType) String() string {
	return "DefaultActionType"
}

func (t DefaultActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return nil, diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return nil, diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DefaultActionValue{
		Bgp:          bgpVal,
		PolicyResult: policyResultVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDefaultActionValueNull() DefaultActionValue {
	return DefaultActionValue{
		state: attr.ValueStateNull,
	}
}

func NewDefaultActionValueUnknown() DefaultActionValue {
	return DefaultActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDefaultActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DefaultActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DefaultActionValue Attribute Value",
				"While creating a DefaultActionValue value, a missing attribute value was detected. "+
					"A DefaultActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DefaultActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DefaultActionValue Attribute Type",
				"While creating a DefaultActionValue value, an invalid attribute value was detected. "+
					"A DefaultActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DefaultActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DefaultActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DefaultActionValue Attribute Value",
				"While creating a DefaultActionValue value, an extra attribute value was detected. "+
					"A DefaultActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DefaultActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDefaultActionValueUnknown(), diags
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return NewDefaultActionValueUnknown(), diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return NewDefaultActionValueUnknown(), diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	if diags.HasError() {
		return NewDefaultActionValueUnknown(), diags
	}

	return DefaultActionValue{
		Bgp:          bgpVal,
		PolicyResult: policyResultVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDefaultActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DefaultActionValue {
	object, diags := NewDefaultActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDefaultActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DefaultActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDefaultActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDefaultActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDefaultActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDefaultActionValueMust(DefaultActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DefaultActionType) ValueType(ctx context.Context) attr.Value {
	return DefaultActionValue{}
}

var _ basetypes.ObjectValuable = DefaultActionValue{}

type DefaultActionValue struct {
	Bgp          basetypes.ObjectValue `tfsdk:"bgp"`
	PolicyResult basetypes.StringValue `tfsdk:"policy_result"`
	state        attr.ValueState
}

func (v DefaultActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: BgpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["policy_result"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Bgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.PolicyResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_result"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DefaultActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DefaultActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DefaultActionValue) String() string {
	return "DefaultActionValue"
}

func (v DefaultActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp basetypes.ObjectValue

	if v.Bgp.IsNull() {
		bgp = types.ObjectNull(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp.IsUnknown() {
		bgp = types.ObjectUnknown(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp.IsNull() && !v.Bgp.IsUnknown() {
		bgp = types.ObjectValueMust(
			BgpValue{}.AttributeTypes(ctx),
			v.Bgp.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":           bgp,
			"policy_result": v.PolicyResult,
		})

	return objVal, diags
}

func (v DefaultActionValue) Equal(o attr.Value) bool {
	other, ok := o.(DefaultActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp.Equal(other.Bgp) {
		return false
	}

	if !v.PolicyResult.Equal(other.PolicyResult) {
		return false
	}

	return true
}

func (v DefaultActionValue) Type(ctx context.Context) attr.Type {
	return DefaultActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DefaultActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BgpType{}

type BgpType struct {
	basetypes.ObjectType
}

func (t BgpType) Equal(o attr.Type) bool {
	other, ok := o.(BgpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpType) String() string {
	return "BgpType"
}

func (t BgpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return nil, diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return nil, diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return nil, diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return nil, diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.ObjectValue, was: %T`, communitySetAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	medAttribute, ok := attributes["med"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med is missing from object`)

		return nil, diags
	}

	medVal, ok := medAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med expected to be basetypes.ObjectValue, was: %T`, medAttribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return nil, diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpValue{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet:    communitySetVal,
		LocalPreference: localPreferenceVal,
		Med:             medVal,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgpValueNull() BgpValue {
	return BgpValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpValueUnknown() BgpValue {
	return BgpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpValue Attribute Value",
				"While creating a BgpValue value, a missing attribute value was detected. "+
					"A BgpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpValue Attribute Type",
				"While creating a BgpValue value, an invalid attribute value was detected. "+
					"A BgpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpValue Attribute Value",
				"While creating a BgpValue value, an extra attribute value was detected. "+
					"A BgpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.ObjectValue, was: %T`, communitySetAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	medAttribute, ok := attributes["med"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	medVal, ok := medAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med expected to be basetypes.ObjectValue, was: %T`, medAttribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	return BgpValue{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet:    communitySetVal,
		LocalPreference: localPreferenceVal,
		Med:             medVal,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpValue {
	object, diags := NewBgpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpValueMust(BgpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpType) ValueType(ctx context.Context) attr.Value {
	return BgpValue{}
}

var _ basetypes.ObjectValuable = BgpValue{}

type BgpValue struct {
	AsPathPrepend   basetypes.Int64Value  `tfsdk:"as_path_prepend"`
	AsPathRemove    basetypes.BoolValue   `tfsdk:"as_path_remove"`
	AsPathReplace   basetypes.ListValue   `tfsdk:"as_path_replace"`
	CommunitySet    basetypes.ObjectValue `tfsdk:"community_set"`
	LocalPreference basetypes.Int64Value  `tfsdk:"local_preference"`
	Med             basetypes.ObjectValue `tfsdk:"med"`
	SetOrigin       basetypes.StringValue `tfsdk:"set_origin"`
	state           attr.ValueState
}

func (v BgpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["as_path_prepend"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["as_path_remove"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["as_path_replace"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["community_set"] = basetypes.ObjectType{
		AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["med"] = basetypes.ObjectType{
		AttrTypes: MedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["set_origin"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AsPathPrepend.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_prepend"] = val

		val, err = v.AsPathRemove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_remove"] = val

		val, err = v.AsPathReplace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_replace"] = val

		val, err = v.CommunitySet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_set"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.Med.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["med"] = val

		val, err = v.SetOrigin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["set_origin"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpValue) String() string {
	return "BgpValue"
}

func (v BgpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var communitySet basetypes.ObjectValue

	if v.CommunitySet.IsNull() {
		communitySet = types.ObjectNull(
			CommunitySetValue{}.AttributeTypes(ctx),
		)
	}

	if v.CommunitySet.IsUnknown() {
		communitySet = types.ObjectUnknown(
			CommunitySetValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CommunitySet.IsNull() && !v.CommunitySet.IsUnknown() {
		communitySet = types.ObjectValueMust(
			CommunitySetValue{}.AttributeTypes(ctx),
			v.CommunitySet.Attributes(),
		)
	}

	var med basetypes.ObjectValue

	if v.Med.IsNull() {
		med = types.ObjectNull(
			MedValue{}.AttributeTypes(ctx),
		)
	}

	if v.Med.IsUnknown() {
		med = types.ObjectUnknown(
			MedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Med.IsNull() && !v.Med.IsUnknown() {
		med = types.ObjectValueMust(
			MedValue{}.AttributeTypes(ctx),
			v.Med.Attributes(),
		)
	}

	var asPathReplaceVal basetypes.ListValue
	switch {
	case v.AsPathReplace.IsUnknown():
		asPathReplaceVal = types.ListUnknown(types.Int64Type)
	case v.AsPathReplace.IsNull():
		asPathReplaceVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		asPathReplaceVal, d = types.ListValue(types.Int64Type, v.AsPathReplace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_prepend": basetypes.Int64Type{},
			"as_path_remove":  basetypes.BoolType{},
			"as_path_replace": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"community_set": basetypes.ObjectType{
				AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
			},
			"local_preference": basetypes.Int64Type{},
			"med": basetypes.ObjectType{
				AttrTypes: MedValue{}.AttributeTypes(ctx),
			},
			"set_origin": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set": basetypes.ObjectType{
			AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med": basetypes.ObjectType{
			AttrTypes: MedValue{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_prepend":  v.AsPathPrepend,
			"as_path_remove":   v.AsPathRemove,
			"as_path_replace":  asPathReplaceVal,
			"community_set":    communitySet,
			"local_preference": v.LocalPreference,
			"med":              med,
			"set_origin":       v.SetOrigin,
		})

	return objVal, diags
}

func (v BgpValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathPrepend.Equal(other.AsPathPrepend) {
		return false
	}

	if !v.AsPathRemove.Equal(other.AsPathRemove) {
		return false
	}

	if !v.AsPathReplace.Equal(other.AsPathReplace) {
		return false
	}

	if !v.CommunitySet.Equal(other.CommunitySet) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.Med.Equal(other.Med) {
		return false
	}

	if !v.SetOrigin.Equal(other.SetOrigin) {
		return false
	}

	return true
}

func (v BgpValue) Type(ctx context.Context) attr.Type {
	return BgpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set": basetypes.ObjectType{
			AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med": basetypes.ObjectType{
			AttrTypes: MedValue{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CommunitySetType{}

type CommunitySetType struct {
	basetypes.ObjectType
}

func (t CommunitySetType) Equal(o attr.Type) bool {
	other, ok := o.(CommunitySetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CommunitySetType) String() string {
	return "CommunitySetType"
}

func (t CommunitySetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return nil, diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return nil, diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return nil, diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CommunitySetValue{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySetValueNull() CommunitySetValue {
	return CommunitySetValue{
		state: attr.ValueStateNull,
	}
}

func NewCommunitySetValueUnknown() CommunitySetValue {
	return CommunitySetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCommunitySetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CommunitySetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CommunitySetValue Attribute Value",
				"While creating a CommunitySetValue value, a missing attribute value was detected. "+
					"A CommunitySetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CommunitySetValue Attribute Type",
				"While creating a CommunitySetValue value, an invalid attribute value was detected. "+
					"A CommunitySetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CommunitySetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CommunitySetValue Attribute Value",
				"While creating a CommunitySetValue value, an extra attribute value was detected. "+
					"A CommunitySetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CommunitySetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCommunitySetValueUnknown(), diags
	}

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return NewCommunitySetValueUnknown(), diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return NewCommunitySetValueUnknown(), diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return NewCommunitySetValueUnknown(), diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return NewCommunitySetValueUnknown(), diags
	}

	return CommunitySetValue{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CommunitySetValue {
	object, diags := NewCommunitySetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCommunitySetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CommunitySetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCommunitySetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCommunitySetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCommunitySetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCommunitySetValueMust(CommunitySetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CommunitySetType) ValueType(ctx context.Context) attr.Value {
	return CommunitySetValue{}
}

var _ basetypes.ObjectValuable = CommunitySetValue{}

type CommunitySetValue struct {
	Add     basetypes.ListValue `tfsdk:"add"`
	Remove  basetypes.ListValue `tfsdk:"remove"`
	Replace basetypes.ListValue `tfsdk:"replace"`
	state   attr.ValueState
}

func (v CommunitySetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["add"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remove"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["replace"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Add.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add"] = val

		val, err = v.Remove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove"] = val

		val, err = v.Replace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CommunitySetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CommunitySetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CommunitySetValue) String() string {
	return "CommunitySetValue"
}

func (v CommunitySetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addVal basetypes.ListValue
	switch {
	case v.Add.IsUnknown():
		addVal = types.ListUnknown(types.StringType)
	case v.Add.IsNull():
		addVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addVal, d = types.ListValue(types.StringType, v.Add.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var removeVal basetypes.ListValue
	switch {
	case v.Remove.IsUnknown():
		removeVal = types.ListUnknown(types.StringType)
	case v.Remove.IsNull():
		removeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		removeVal, d = types.ListValue(types.StringType, v.Remove.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var replaceVal basetypes.ListValue
	switch {
	case v.Replace.IsUnknown():
		replaceVal = types.ListUnknown(types.StringType)
	case v.Replace.IsNull():
		replaceVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		replaceVal, d = types.ListValue(types.StringType, v.Replace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"add":     addVal,
			"remove":  removeVal,
			"replace": replaceVal,
		})

	return objVal, diags
}

func (v CommunitySetValue) Equal(o attr.Value) bool {
	other, ok := o.(CommunitySetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Add.Equal(other.Add) {
		return false
	}

	if !v.Remove.Equal(other.Remove) {
		return false
	}

	if !v.Replace.Equal(other.Replace) {
		return false
	}

	return true
}

func (v CommunitySetValue) Type(ctx context.Context) attr.Type {
	return CommunitySetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CommunitySetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = MedType{}

type MedType struct {
	basetypes.ObjectType
}

func (t MedType) Equal(o attr.Type) bool {
	other, ok := o.(MedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MedType) String() string {
	return "MedType"
}

func (t MedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return nil, diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return nil, diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return nil, diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MedValue{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMedValueNull() MedValue {
	return MedValue{
		state: attr.ValueStateNull,
	}
}

func NewMedValueUnknown() MedValue {
	return MedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MedValue Attribute Value",
				"While creating a MedValue value, a missing attribute value was detected. "+
					"A MedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MedValue Attribute Type",
				"While creating a MedValue value, an invalid attribute value was detected. "+
					"A MedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MedValue Attribute Value",
				"While creating a MedValue value, an extra attribute value was detected. "+
					"A MedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMedValueUnknown(), diags
	}

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return NewMedValueUnknown(), diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return NewMedValueUnknown(), diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return NewMedValueUnknown(), diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return NewMedValueUnknown(), diags
	}

	return MedValue{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MedValue {
	object, diags := NewMedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMedValueMust(MedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MedType) ValueType(ctx context.Context) attr.Value {
	return MedValue{}
}

var _ basetypes.ObjectValuable = MedValue{}

type MedValue struct {
	NumericalValue basetypes.Int64Value  `tfsdk:"numerical_value"`
	Operation      basetypes.StringValue `tfsdk:"operation"`
	ValueType      basetypes.StringValue `tfsdk:"value_type"`
	state          attr.ValueState
}

func (v MedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["numerical_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NumericalValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["numerical_value"] = val

		val, err = v.Operation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operation"] = val

		val, err = v.ValueType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MedValue) String() string {
	return "MedValue"
}

func (v MedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"numerical_value": v.NumericalValue,
			"operation":       v.Operation,
			"value_type":      v.ValueType,
		})

	return objVal, diags
}

func (v MedValue) Equal(o attr.Value) bool {
	other, ok := o.(MedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumericalValue.Equal(other.NumericalValue) {
		return false
	}

	if !v.Operation.Equal(other.Operation) {
		return false
	}

	if !v.ValueType.Equal(other.ValueType) {
		return false
	}

	return true
}

func (v MedValue) Type(ctx context.Context) attr.Type {
	return MedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatementType{}

type StatementType struct {
	basetypes.ObjectType
}

func (t StatementType) Equal(o attr.Type) bool {
	other, ok := o.(StatementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatementType) String() string {
	return "StatementType"
}

func (t StatementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.ObjectValue, was: %T`, matchAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatementValue{
		Action: actionVal,
		Match:  matchVal,
		Name:   nameVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewStatementValueNull() StatementValue {
	return StatementValue{
		state: attr.ValueStateNull,
	}
}

func NewStatementValueUnknown() StatementValue {
	return StatementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatementValue Attribute Value",
				"While creating a StatementValue value, a missing attribute value was detected. "+
					"A StatementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatementValue Attribute Type",
				"While creating a StatementValue value, an invalid attribute value was detected. "+
					"A StatementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatementValue Attribute Value",
				"While creating a StatementValue value, an extra attribute value was detected. "+
					"A StatementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatementValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.ObjectValue, was: %T`, matchAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewStatementValueUnknown(), diags
	}

	return StatementValue{
		Action: actionVal,
		Match:  matchVal,
		Name:   nameVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewStatementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatementValue {
	object, diags := NewStatementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatementValueMust(StatementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatementType) ValueType(ctx context.Context) attr.Value {
	return StatementValue{}
}

var _ basetypes.ObjectValuable = StatementValue{}

type StatementValue struct {
	Action basetypes.ObjectValue `tfsdk:"action"`
	Match  basetypes.ObjectValue `tfsdk:"match"`
	Name   basetypes.StringValue `tfsdk:"name"`
	state  attr.ValueState
}

func (v StatementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.ObjectType{
		AttrTypes: ActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["match"] = basetypes.ObjectType{
		AttrTypes: MatchValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatementValue) String() string {
	return "StatementValue"
}

func (v StatementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var action basetypes.ObjectValue

	if v.Action.IsNull() {
		action = types.ObjectNull(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Action.IsUnknown() {
		action = types.ObjectUnknown(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Action.IsNull() && !v.Action.IsUnknown() {
		action = types.ObjectValueMust(
			ActionValue{}.AttributeTypes(ctx),
			v.Action.Attributes(),
		)
	}

	var match basetypes.ObjectValue

	if v.Match.IsNull() {
		match = types.ObjectNull(
			MatchValue{}.AttributeTypes(ctx),
		)
	}

	if v.Match.IsUnknown() {
		match = types.ObjectUnknown(
			MatchValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Match.IsNull() && !v.Match.IsUnknown() {
		match = types.ObjectValueMust(
			MatchValue{}.AttributeTypes(ctx),
			v.Match.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"match": basetypes.ObjectType{
			AttrTypes: MatchValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action": action,
			"match":  match,
			"name":   v.Name,
		})

	return objVal, diags
}

func (v StatementValue) Equal(o attr.Value) bool {
	other, ok := o.(StatementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v StatementValue) Type(ctx context.Context) attr.Type {
	return StatementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"match": basetypes.ObjectType{
			AttrTypes: MatchValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ActionType{}

type ActionType struct {
	basetypes.ObjectType
}

func (t ActionType) Equal(o attr.Type) bool {
	other, ok := o.(ActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionType) String() string {
	return "ActionType"
}

func (t ActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgp1Attribute, ok := attributes["bgp_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_1 is missing from object`)

		return nil, diags
	}

	bgp1Val, ok := bgp1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_1 expected to be basetypes.ObjectValue, was: %T`, bgp1Attribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return nil, diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionValue{
		Bgp1:         bgp1Val,
		PolicyResult: policyResultVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewActionValueNull() ActionValue {
	return ActionValue{
		state: attr.ValueStateNull,
	}
}

func NewActionValueUnknown() ActionValue {
	return ActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionValue Attribute Value",
				"While creating a ActionValue value, a missing attribute value was detected. "+
					"A ActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionValue Attribute Type",
				"While creating a ActionValue value, an invalid attribute value was detected. "+
					"A ActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionValue Attribute Value",
				"While creating a ActionValue value, an extra attribute value was detected. "+
					"A ActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	bgp1Attribute, ok := attributes["bgp_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_1 is missing from object`)

		return NewActionValueUnknown(), diags
	}

	bgp1Val, ok := bgp1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_1 expected to be basetypes.ObjectValue, was: %T`, bgp1Attribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return NewActionValueUnknown(), diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	return ActionValue{
		Bgp1:         bgp1Val,
		PolicyResult: policyResultVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionValue {
	object, diags := NewActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionValueMust(ActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionType) ValueType(ctx context.Context) attr.Value {
	return ActionValue{}
}

var _ basetypes.ObjectValuable = ActionValue{}

type ActionValue struct {
	Bgp1         basetypes.ObjectValue `tfsdk:"bgp_1"`
	PolicyResult basetypes.StringValue `tfsdk:"policy_result"`
	state        attr.ValueState
}

func (v ActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bgp_1"] = basetypes.ObjectType{
		AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["policy_result"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Bgp1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_1"] = val

		val, err = v.PolicyResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_result"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionValue) String() string {
	return "ActionValue"
}

func (v ActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp1 basetypes.ObjectValue

	if v.Bgp1.IsNull() {
		bgp1 = types.ObjectNull(
			Bgp1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp1.IsUnknown() {
		bgp1 = types.ObjectUnknown(
			Bgp1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp1.IsNull() && !v.Bgp1.IsUnknown() {
		bgp1 = types.ObjectValueMust(
			Bgp1Value{}.AttributeTypes(ctx),
			v.Bgp1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bgp_1": basetypes.ObjectType{
			AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp_1":         bgp1,
			"policy_result": v.PolicyResult,
		})

	return objVal, diags
}

func (v ActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp1.Equal(other.Bgp1) {
		return false
	}

	if !v.PolicyResult.Equal(other.PolicyResult) {
		return false
	}

	return true
}

func (v ActionValue) Type(ctx context.Context) attr.Type {
	return ActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp_1": basetypes.ObjectType{
			AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Bgp1Type{}

type Bgp1Type struct {
	basetypes.ObjectType
}

func (t Bgp1Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp1Type) String() string {
	return "Bgp1Type"
}

func (t Bgp1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return nil, diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return nil, diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return nil, diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySet1Attribute, ok := attributes["community_set_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set_1 is missing from object`)

		return nil, diags
	}

	communitySet1Val, ok := communitySet1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set_1 expected to be basetypes.ObjectValue, was: %T`, communitySet1Attribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	med1Attribute, ok := attributes["med_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med_1 is missing from object`)

		return nil, diags
	}

	med1Val, ok := med1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med_1 expected to be basetypes.ObjectValue, was: %T`, med1Attribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return nil, diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp1Value{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet1:   communitySet1Val,
		LocalPreference: localPreferenceVal,
		Med1:            med1Val,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgp1ValueNull() Bgp1Value {
	return Bgp1Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp1ValueUnknown() Bgp1Value {
	return Bgp1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp1Value Attribute Value",
				"While creating a Bgp1Value value, a missing attribute value was detected. "+
					"A Bgp1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp1Value Attribute Type",
				"While creating a Bgp1Value value, an invalid attribute value was detected. "+
					"A Bgp1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp1Value Attribute Value",
				"While creating a Bgp1Value value, an extra attribute value was detected. "+
					"A Bgp1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp1ValueUnknown(), diags
	}

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySet1Attribute, ok := attributes["community_set_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set_1 is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	communitySet1Val, ok := communitySet1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set_1 expected to be basetypes.ObjectValue, was: %T`, communitySet1Attribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	med1Attribute, ok := attributes["med_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med_1 is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	med1Val, ok := med1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med_1 expected to be basetypes.ObjectValue, was: %T`, med1Attribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return NewBgp1ValueUnknown(), diags
	}

	return Bgp1Value{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet1:   communitySet1Val,
		LocalPreference: localPreferenceVal,
		Med1:            med1Val,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgp1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp1Value {
	object, diags := NewBgp1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp1ValueMust(Bgp1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp1Type) ValueType(ctx context.Context) attr.Value {
	return Bgp1Value{}
}

var _ basetypes.ObjectValuable = Bgp1Value{}

type Bgp1Value struct {
	AsPathPrepend   basetypes.Int64Value  `tfsdk:"as_path_prepend"`
	AsPathRemove    basetypes.BoolValue   `tfsdk:"as_path_remove"`
	AsPathReplace   basetypes.ListValue   `tfsdk:"as_path_replace"`
	CommunitySet1   basetypes.ObjectValue `tfsdk:"community_set_1"`
	LocalPreference basetypes.Int64Value  `tfsdk:"local_preference"`
	Med1            basetypes.ObjectValue `tfsdk:"med_1"`
	SetOrigin       basetypes.StringValue `tfsdk:"set_origin"`
	state           attr.ValueState
}

func (v Bgp1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["as_path_prepend"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["as_path_remove"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["as_path_replace"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["community_set_1"] = basetypes.ObjectType{
		AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["med_1"] = basetypes.ObjectType{
		AttrTypes: Med1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["set_origin"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AsPathPrepend.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_prepend"] = val

		val, err = v.AsPathRemove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_remove"] = val

		val, err = v.AsPathReplace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_replace"] = val

		val, err = v.CommunitySet1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_set_1"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.Med1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["med_1"] = val

		val, err = v.SetOrigin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["set_origin"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp1Value) String() string {
	return "Bgp1Value"
}

func (v Bgp1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var communitySet1 basetypes.ObjectValue

	if v.CommunitySet1.IsNull() {
		communitySet1 = types.ObjectNull(
			CommunitySet1Value{}.AttributeTypes(ctx),
		)
	}

	if v.CommunitySet1.IsUnknown() {
		communitySet1 = types.ObjectUnknown(
			CommunitySet1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.CommunitySet1.IsNull() && !v.CommunitySet1.IsUnknown() {
		communitySet1 = types.ObjectValueMust(
			CommunitySet1Value{}.AttributeTypes(ctx),
			v.CommunitySet1.Attributes(),
		)
	}

	var med1 basetypes.ObjectValue

	if v.Med1.IsNull() {
		med1 = types.ObjectNull(
			Med1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Med1.IsUnknown() {
		med1 = types.ObjectUnknown(
			Med1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Med1.IsNull() && !v.Med1.IsUnknown() {
		med1 = types.ObjectValueMust(
			Med1Value{}.AttributeTypes(ctx),
			v.Med1.Attributes(),
		)
	}

	var asPathReplaceVal basetypes.ListValue
	switch {
	case v.AsPathReplace.IsUnknown():
		asPathReplaceVal = types.ListUnknown(types.Int64Type)
	case v.AsPathReplace.IsNull():
		asPathReplaceVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		asPathReplaceVal, d = types.ListValue(types.Int64Type, v.AsPathReplace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_prepend": basetypes.Int64Type{},
			"as_path_remove":  basetypes.BoolType{},
			"as_path_replace": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"community_set_1": basetypes.ObjectType{
				AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
			},
			"local_preference": basetypes.Int64Type{},
			"med_1": basetypes.ObjectType{
				AttrTypes: Med1Value{}.AttributeTypes(ctx),
			},
			"set_origin": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set_1": basetypes.ObjectType{
			AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med_1": basetypes.ObjectType{
			AttrTypes: Med1Value{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_prepend":  v.AsPathPrepend,
			"as_path_remove":   v.AsPathRemove,
			"as_path_replace":  asPathReplaceVal,
			"community_set_1":  communitySet1,
			"local_preference": v.LocalPreference,
			"med_1":            med1,
			"set_origin":       v.SetOrigin,
		})

	return objVal, diags
}

func (v Bgp1Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathPrepend.Equal(other.AsPathPrepend) {
		return false
	}

	if !v.AsPathRemove.Equal(other.AsPathRemove) {
		return false
	}

	if !v.AsPathReplace.Equal(other.AsPathReplace) {
		return false
	}

	if !v.CommunitySet1.Equal(other.CommunitySet1) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.Med1.Equal(other.Med1) {
		return false
	}

	if !v.SetOrigin.Equal(other.SetOrigin) {
		return false
	}

	return true
}

func (v Bgp1Value) Type(ctx context.Context) attr.Type {
	return Bgp1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set_1": basetypes.ObjectType{
			AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med_1": basetypes.ObjectType{
			AttrTypes: Med1Value{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CommunitySet1Type{}

type CommunitySet1Type struct {
	basetypes.ObjectType
}

func (t CommunitySet1Type) Equal(o attr.Type) bool {
	other, ok := o.(CommunitySet1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CommunitySet1Type) String() string {
	return "CommunitySet1Type"
}

func (t CommunitySet1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return nil, diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return nil, diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return nil, diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CommunitySet1Value{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySet1ValueNull() CommunitySet1Value {
	return CommunitySet1Value{
		state: attr.ValueStateNull,
	}
}

func NewCommunitySet1ValueUnknown() CommunitySet1Value {
	return CommunitySet1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewCommunitySet1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CommunitySet1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CommunitySet1Value Attribute Value",
				"While creating a CommunitySet1Value value, a missing attribute value was detected. "+
					"A CommunitySet1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySet1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CommunitySet1Value Attribute Type",
				"While creating a CommunitySet1Value value, an invalid attribute value was detected. "+
					"A CommunitySet1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySet1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CommunitySet1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CommunitySet1Value Attribute Value",
				"While creating a CommunitySet1Value value, an extra attribute value was detected. "+
					"A CommunitySet1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CommunitySet1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCommunitySet1ValueUnknown(), diags
	}

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return NewCommunitySet1ValueUnknown(), diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return NewCommunitySet1ValueUnknown(), diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return NewCommunitySet1ValueUnknown(), diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return NewCommunitySet1ValueUnknown(), diags
	}

	return CommunitySet1Value{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySet1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CommunitySet1Value {
	object, diags := NewCommunitySet1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCommunitySet1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CommunitySet1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCommunitySet1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCommunitySet1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCommunitySet1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCommunitySet1ValueMust(CommunitySet1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t CommunitySet1Type) ValueType(ctx context.Context) attr.Value {
	return CommunitySet1Value{}
}

var _ basetypes.ObjectValuable = CommunitySet1Value{}

type CommunitySet1Value struct {
	Add     basetypes.ListValue `tfsdk:"add"`
	Remove  basetypes.ListValue `tfsdk:"remove"`
	Replace basetypes.ListValue `tfsdk:"replace"`
	state   attr.ValueState
}

func (v CommunitySet1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["add"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remove"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["replace"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Add.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add"] = val

		val, err = v.Remove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove"] = val

		val, err = v.Replace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CommunitySet1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CommunitySet1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CommunitySet1Value) String() string {
	return "CommunitySet1Value"
}

func (v CommunitySet1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addVal basetypes.ListValue
	switch {
	case v.Add.IsUnknown():
		addVal = types.ListUnknown(types.StringType)
	case v.Add.IsNull():
		addVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addVal, d = types.ListValue(types.StringType, v.Add.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var removeVal basetypes.ListValue
	switch {
	case v.Remove.IsUnknown():
		removeVal = types.ListUnknown(types.StringType)
	case v.Remove.IsNull():
		removeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		removeVal, d = types.ListValue(types.StringType, v.Remove.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var replaceVal basetypes.ListValue
	switch {
	case v.Replace.IsUnknown():
		replaceVal = types.ListUnknown(types.StringType)
	case v.Replace.IsNull():
		replaceVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		replaceVal, d = types.ListValue(types.StringType, v.Replace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"add":     addVal,
			"remove":  removeVal,
			"replace": replaceVal,
		})

	return objVal, diags
}

func (v CommunitySet1Value) Equal(o attr.Value) bool {
	other, ok := o.(CommunitySet1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Add.Equal(other.Add) {
		return false
	}

	if !v.Remove.Equal(other.Remove) {
		return false
	}

	if !v.Replace.Equal(other.Replace) {
		return false
	}

	return true
}

func (v CommunitySet1Value) Type(ctx context.Context) attr.Type {
	return CommunitySet1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CommunitySet1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Med1Type{}

type Med1Type struct {
	basetypes.ObjectType
}

func (t Med1Type) Equal(o attr.Type) bool {
	other, ok := o.(Med1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Med1Type) String() string {
	return "Med1Type"
}

func (t Med1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return nil, diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return nil, diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return nil, diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Med1Value{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMed1ValueNull() Med1Value {
	return Med1Value{
		state: attr.ValueStateNull,
	}
}

func NewMed1ValueUnknown() Med1Value {
	return Med1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMed1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Med1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Med1Value Attribute Value",
				"While creating a Med1Value value, a missing attribute value was detected. "+
					"A Med1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Med1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Med1Value Attribute Type",
				"While creating a Med1Value value, an invalid attribute value was detected. "+
					"A Med1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Med1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Med1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Med1Value Attribute Value",
				"While creating a Med1Value value, an extra attribute value was detected. "+
					"A Med1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Med1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMed1ValueUnknown(), diags
	}

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return NewMed1ValueUnknown(), diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return NewMed1ValueUnknown(), diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return NewMed1ValueUnknown(), diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return NewMed1ValueUnknown(), diags
	}

	return Med1Value{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMed1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Med1Value {
	object, diags := NewMed1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMed1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Med1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMed1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMed1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMed1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMed1ValueMust(Med1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Med1Type) ValueType(ctx context.Context) attr.Value {
	return Med1Value{}
}

var _ basetypes.ObjectValuable = Med1Value{}

type Med1Value struct {
	NumericalValue basetypes.Int64Value  `tfsdk:"numerical_value"`
	Operation      basetypes.StringValue `tfsdk:"operation"`
	ValueType      basetypes.StringValue `tfsdk:"value_type"`
	state          attr.ValueState
}

func (v Med1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["numerical_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NumericalValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["numerical_value"] = val

		val, err = v.Operation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operation"] = val

		val, err = v.ValueType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Med1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Med1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Med1Value) String() string {
	return "Med1Value"
}

func (v Med1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"numerical_value": v.NumericalValue,
			"operation":       v.Operation,
			"value_type":      v.ValueType,
		})

	return objVal, diags
}

func (v Med1Value) Equal(o attr.Value) bool {
	other, ok := o.(Med1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumericalValue.Equal(other.NumericalValue) {
		return false
	}

	if !v.Operation.Equal(other.Operation) {
		return false
	}

	if !v.ValueType.Equal(other.ValueType) {
		return false
	}

	return true
}

func (v Med1Value) Type(ctx context.Context) attr.Type {
	return Med1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Med1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MatchType{}

type MatchType struct {
	basetypes.ObjectType
}

func (t MatchType) Equal(o attr.Type) bool {
	other, ok := o.(MatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchType) String() string {
	return "MatchType"
}

func (t MatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgp2Attribute, ok := attributes["bgp_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_2 is missing from object`)

		return nil, diags
	}

	bgp2Val, ok := bgp2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_2 expected to be basetypes.ObjectValue, was: %T`, bgp2Attribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return nil, diags
	}

	familyVal, ok := familyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.ListValue, was: %T`, familyAttribute))
	}

	prefixSetAttribute, ok := attributes["prefix_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_set is missing from object`)

		return nil, diags
	}

	prefixSetVal, ok := prefixSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_set expected to be basetypes.StringValue, was: %T`, prefixSetAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchValue{
		Bgp2:      bgp2Val,
		Family:    familyVal,
		PrefixSet: prefixSetVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMatchValueNull() MatchValue {
	return MatchValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchValueUnknown() MatchValue {
	return MatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchValue Attribute Value",
				"While creating a MatchValue value, a missing attribute value was detected. "+
					"A MatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchValue Attribute Type",
				"While creating a MatchValue value, an invalid attribute value was detected. "+
					"A MatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchValue Attribute Value",
				"While creating a MatchValue value, an extra attribute value was detected. "+
					"A MatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchValueUnknown(), diags
	}

	bgp2Attribute, ok := attributes["bgp_2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_2 is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	bgp2Val, ok := bgp2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_2 expected to be basetypes.ObjectValue, was: %T`, bgp2Attribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	familyVal, ok := familyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.ListValue, was: %T`, familyAttribute))
	}

	prefixSetAttribute, ok := attributes["prefix_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_set is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	prefixSetVal, ok := prefixSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_set expected to be basetypes.StringValue, was: %T`, prefixSetAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewMatchValueUnknown(), diags
	}

	return MatchValue{
		Bgp2:      bgp2Val,
		Family:    familyVal,
		PrefixSet: prefixSetVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchValue {
	object, diags := NewMatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchValueMust(MatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchType) ValueType(ctx context.Context) attr.Value {
	return MatchValue{}
}

var _ basetypes.ObjectValuable = MatchValue{}

type MatchValue struct {
	Bgp2      basetypes.ObjectValue `tfsdk:"bgp_2"`
	Family    basetypes.ListValue   `tfsdk:"family"`
	PrefixSet basetypes.StringValue `tfsdk:"prefix_set"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	state     attr.ValueState
}

func (v MatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bgp_2"] = basetypes.ObjectType{
		AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["prefix_set"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bgp2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_2"] = val

		val, err = v.Family.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family"] = val

		val, err = v.PrefixSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_set"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchValue) String() string {
	return "MatchValue"
}

func (v MatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp2 basetypes.ObjectValue

	if v.Bgp2.IsNull() {
		bgp2 = types.ObjectNull(
			Bgp2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp2.IsUnknown() {
		bgp2 = types.ObjectUnknown(
			Bgp2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp2.IsNull() && !v.Bgp2.IsUnknown() {
		bgp2 = types.ObjectValueMust(
			Bgp2Value{}.AttributeTypes(ctx),
			v.Bgp2.Attributes(),
		)
	}

	var familyVal basetypes.ListValue
	switch {
	case v.Family.IsUnknown():
		familyVal = types.ListUnknown(types.StringType)
	case v.Family.IsNull():
		familyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		familyVal, d = types.ListValue(types.StringType, v.Family.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp_2": basetypes.ObjectType{
				AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
			},
			"family": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix_set": basetypes.StringType{},
			"protocol":   basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bgp_2": basetypes.ObjectType{
			AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
		},
		"family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix_set": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp_2":      bgp2,
			"family":     familyVal,
			"prefix_set": v.PrefixSet,
			"protocol":   v.Protocol,
		})

	return objVal, diags
}

func (v MatchValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp2.Equal(other.Bgp2) {
		return false
	}

	if !v.Family.Equal(other.Family) {
		return false
	}

	if !v.PrefixSet.Equal(other.PrefixSet) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v MatchValue) Type(ctx context.Context) attr.Type {
	return MatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp_2": basetypes.ObjectType{
			AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
		},
		"family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix_set": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Bgp2Type{}

type Bgp2Type struct {
	basetypes.ObjectType
}

func (t Bgp2Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp2Type) String() string {
	return "Bgp2Type"
}

func (t Bgp2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathMatchAttribute, ok := attributes["as_path_match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_match is missing from object`)

		return nil, diags
	}

	asPathMatchVal, ok := asPathMatchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_match expected to be basetypes.ObjectValue, was: %T`, asPathMatchAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return nil, diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.StringValue, was: %T`, communitySetAttribute))
	}

	evpnRouteTypeAttribute, ok := attributes["evpn_route_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_type is missing from object`)

		return nil, diags
	}

	evpnRouteTypeVal, ok := evpnRouteTypeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_type expected to be basetypes.ListValue, was: %T`, evpnRouteTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp2Value{
		AsPathMatch:   asPathMatchVal,
		CommunitySet:  communitySetVal,
		EvpnRouteType: evpnRouteTypeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBgp2ValueNull() Bgp2Value {
	return Bgp2Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp2ValueUnknown() Bgp2Value {
	return Bgp2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp2Value Attribute Value",
				"While creating a Bgp2Value value, a missing attribute value was detected. "+
					"A Bgp2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp2Value Attribute Type",
				"While creating a Bgp2Value value, an invalid attribute value was detected. "+
					"A Bgp2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp2Value Attribute Value",
				"While creating a Bgp2Value value, an extra attribute value was detected. "+
					"A Bgp2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp2ValueUnknown(), diags
	}

	asPathMatchAttribute, ok := attributes["as_path_match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_match is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	asPathMatchVal, ok := asPathMatchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_match expected to be basetypes.ObjectValue, was: %T`, asPathMatchAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.StringValue, was: %T`, communitySetAttribute))
	}

	evpnRouteTypeAttribute, ok := attributes["evpn_route_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_type is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	evpnRouteTypeVal, ok := evpnRouteTypeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_type expected to be basetypes.ListValue, was: %T`, evpnRouteTypeAttribute))
	}

	if diags.HasError() {
		return NewBgp2ValueUnknown(), diags
	}

	return Bgp2Value{
		AsPathMatch:   asPathMatchVal,
		CommunitySet:  communitySetVal,
		EvpnRouteType: evpnRouteTypeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBgp2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp2Value {
	object, diags := NewBgp2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp2ValueMust(Bgp2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp2Type) ValueType(ctx context.Context) attr.Value {
	return Bgp2Value{}
}

var _ basetypes.ObjectValuable = Bgp2Value{}

type Bgp2Value struct {
	AsPathMatch   basetypes.ObjectValue `tfsdk:"as_path_match"`
	CommunitySet  basetypes.StringValue `tfsdk:"community_set"`
	EvpnRouteType basetypes.ListValue   `tfsdk:"evpn_route_type"`
	state         attr.ValueState
}

func (v Bgp2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["as_path_match"] = basetypes.ObjectType{
		AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["community_set"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evpn_route_type"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AsPathMatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_match"] = val

		val, err = v.CommunitySet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_set"] = val

		val, err = v.EvpnRouteType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_route_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp2Value) String() string {
	return "Bgp2Value"
}

func (v Bgp2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var asPathMatch basetypes.ObjectValue

	if v.AsPathMatch.IsNull() {
		asPathMatch = types.ObjectNull(
			AsPathMatchValue{}.AttributeTypes(ctx),
		)
	}

	if v.AsPathMatch.IsUnknown() {
		asPathMatch = types.ObjectUnknown(
			AsPathMatchValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AsPathMatch.IsNull() && !v.AsPathMatch.IsUnknown() {
		asPathMatch = types.ObjectValueMust(
			AsPathMatchValue{}.AttributeTypes(ctx),
			v.AsPathMatch.Attributes(),
		)
	}

	var evpnRouteTypeVal basetypes.ListValue
	switch {
	case v.EvpnRouteType.IsUnknown():
		evpnRouteTypeVal = types.ListUnknown(types.Int64Type)
	case v.EvpnRouteType.IsNull():
		evpnRouteTypeVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		evpnRouteTypeVal, d = types.ListValue(types.Int64Type, v.EvpnRouteType.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_match": basetypes.ObjectType{
				AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
			},
			"community_set": basetypes.StringType{},
			"evpn_route_type": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_match": basetypes.ObjectType{
			AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
		},
		"community_set": basetypes.StringType{},
		"evpn_route_type": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_match":   asPathMatch,
			"community_set":   v.CommunitySet,
			"evpn_route_type": evpnRouteTypeVal,
		})

	return objVal, diags
}

func (v Bgp2Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathMatch.Equal(other.AsPathMatch) {
		return false
	}

	if !v.CommunitySet.Equal(other.CommunitySet) {
		return false
	}

	if !v.EvpnRouteType.Equal(other.EvpnRouteType) {
		return false
	}

	return true
}

func (v Bgp2Value) Type(ctx context.Context) attr.Type {
	return Bgp2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_match": basetypes.ObjectType{
			AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
		},
		"community_set": basetypes.StringType{},
		"evpn_route_type": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = AsPathMatchType{}

type AsPathMatchType struct {
	basetypes.ObjectType
}

func (t AsPathMatchType) Equal(o attr.Type) bool {
	other, ok := o.(AsPathMatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsPathMatchType) String() string {
	return "AsPathMatchType"
}

func (t AsPathMatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathExpressionAttribute, ok := attributes["as_path_expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_expression is missing from object`)

		return nil, diags
	}

	asPathExpressionVal, ok := asPathExpressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_expression expected to be basetypes.StringValue, was: %T`, asPathExpressionAttribute))
	}

	asPathSetAttribute, ok := attributes["as_path_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_set is missing from object`)

		return nil, diags
	}

	asPathSetVal, ok := asPathSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_set expected to be basetypes.StringValue, was: %T`, asPathSetAttribute))
	}

	matchSetOptionsAttribute, ok := attributes["match_set_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_set_options is missing from object`)

		return nil, diags
	}

	matchSetOptionsVal, ok := matchSetOptionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_set_options expected to be basetypes.StringValue, was: %T`, matchSetOptionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsPathMatchValue{
		AsPathExpression: asPathExpressionVal,
		AsPathSet:        asPathSetVal,
		MatchSetOptions:  matchSetOptionsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAsPathMatchValueNull() AsPathMatchValue {
	return AsPathMatchValue{
		state: attr.ValueStateNull,
	}
}

func NewAsPathMatchValueUnknown() AsPathMatchValue {
	return AsPathMatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAsPathMatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsPathMatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsPathMatchValue Attribute Value",
				"While creating a AsPathMatchValue value, a missing attribute value was detected. "+
					"A AsPathMatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathMatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsPathMatchValue Attribute Type",
				"While creating a AsPathMatchValue value, an invalid attribute value was detected. "+
					"A AsPathMatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathMatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsPathMatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsPathMatchValue Attribute Value",
				"While creating a AsPathMatchValue value, an extra attribute value was detected. "+
					"A AsPathMatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsPathMatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsPathMatchValueUnknown(), diags
	}

	asPathExpressionAttribute, ok := attributes["as_path_expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_expression is missing from object`)

		return NewAsPathMatchValueUnknown(), diags
	}

	asPathExpressionVal, ok := asPathExpressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_expression expected to be basetypes.StringValue, was: %T`, asPathExpressionAttribute))
	}

	asPathSetAttribute, ok := attributes["as_path_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_set is missing from object`)

		return NewAsPathMatchValueUnknown(), diags
	}

	asPathSetVal, ok := asPathSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_set expected to be basetypes.StringValue, was: %T`, asPathSetAttribute))
	}

	matchSetOptionsAttribute, ok := attributes["match_set_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_set_options is missing from object`)

		return NewAsPathMatchValueUnknown(), diags
	}

	matchSetOptionsVal, ok := matchSetOptionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_set_options expected to be basetypes.StringValue, was: %T`, matchSetOptionsAttribute))
	}

	if diags.HasError() {
		return NewAsPathMatchValueUnknown(), diags
	}

	return AsPathMatchValue{
		AsPathExpression: asPathExpressionVal,
		AsPathSet:        asPathSetVal,
		MatchSetOptions:  matchSetOptionsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAsPathMatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsPathMatchValue {
	object, diags := NewAsPathMatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsPathMatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsPathMatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsPathMatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsPathMatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsPathMatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsPathMatchValueMust(AsPathMatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AsPathMatchType) ValueType(ctx context.Context) attr.Value {
	return AsPathMatchValue{}
}

var _ basetypes.ObjectValuable = AsPathMatchValue{}

type AsPathMatchValue struct {
	AsPathExpression basetypes.StringValue `tfsdk:"as_path_expression"`
	AsPathSet        basetypes.StringValue `tfsdk:"as_path_set"`
	MatchSetOptions  basetypes.StringValue `tfsdk:"match_set_options"`
	state            attr.ValueState
}

func (v AsPathMatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["as_path_expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["as_path_set"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match_set_options"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AsPathExpression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_expression"] = val

		val, err = v.AsPathSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_set"] = val

		val, err = v.MatchSetOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_set_options"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsPathMatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsPathMatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsPathMatchValue) String() string {
	return "AsPathMatchValue"
}

func (v AsPathMatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as_path_expression": basetypes.StringType{},
		"as_path_set":        basetypes.StringType{},
		"match_set_options":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_expression": v.AsPathExpression,
			"as_path_set":        v.AsPathSet,
			"match_set_options":  v.MatchSetOptions,
		})

	return objVal, diags
}

func (v AsPathMatchValue) Equal(o attr.Value) bool {
	other, ok := o.(AsPathMatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathExpression.Equal(other.AsPathExpression) {
		return false
	}

	if !v.AsPathSet.Equal(other.AsPathSet) {
		return false
	}

	if !v.MatchSetOptions.Equal(other.MatchSetOptions) {
		return false
	}

	return true
}

func (v AsPathMatchValue) Type(ctx context.Context) attr.Type {
	return AsPathMatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsPathMatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_expression": basetypes.StringType{},
		"as_path_set":        basetypes.StringType{},
		"match_set_options":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
